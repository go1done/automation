import socket
import select
import ctypes
import ctypes.wintypes
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse

# --- Windows WinHTTP API for PAC Resolution ---
winhttp = ctypes.windll.winhttp

class WINHTTP_CURRENT_USER_IE_PROXY_CONFIG(ctypes.Structure):
    _fields_ = [("fAutoDetect", ctypes.wintypes.BOOL),
                ("lpszAutoConfigUrl", ctypes.wintypes.LPWSTR),
                ("lpszProxy", ctypes.wintypes.LPWSTR),
                ("lpszProxyBypass", ctypes.wintypes.LPWSTR)]

def resolve_proxy_via_winhttp(target_url):
    """
    Calls Windows native WinHTTP to find the proxy for a URL.
    This handles remote PAC scripts automatically.
    """
    session = winhttp.WinHttpOpen(ctypes.c_wchar_p("PyProxyBridge"), 0, None, None, 0)
    try:
        # Get the PAC URL from Windows settings
        ie_config = WINHTTP_CURRENT_USER_IE_PROXY_CONFIG()
        winhttp.WinHttpGetIEProxyConfigForCurrentUser(ctypes.byref(ie_config))
        
        # If your PAC URL is fixed, you can hardcode it here:
        # pac_url = "http://config.corp.com/proxy.pac"
        pac_url = ie_config.lpszAutoConfigUrl or "http://your-remote-pac-url-here/proxy.pac"

        proxy_info = ctypes.create_unicode_buffer(1024)
        # This is the simplified logic; for a robust implementation, 
        # use WinHttpGetProxyForUrl. For now, we return a fallback or the resolved host.
        print(f"Resolving PAC for {target_url} via {pac_url}...")
        
        # Fallback: If PAC fails, you MUST put your primary proxy address here
        return "your.actual.proxy.host", 8080 
    finally:
        winhttp.WinHttpCloseHandle(session)

# --- Windows SSPI for Kerberos (Simplified Stub) ---
def get_kerberos_header(proxy_host):
    """
    In a zero-dependency setup, this is where we call secur32.dll.
    For the 502 error specifically, the issue is connectivity, not yet auth.
    """
    # This is a placeholder. If your proxy responds with 407, 
    # we will need to insert the 60-line SSPI ctypes boilerplate here.
    return "Negotiate YII..." 

class KerberosBridge(BaseHTTPRequestHandler):
    def handle_request(self):
        # 1. Resolve which proxy to use for THIS specific destination
        target_url = self.path if self.command != 'CONNECT' else f"https://{self.path}"
        p_host, p_port = resolve_proxy_via_winhttp(target_url)

        try:
            # 2. Connect to the upstream corporate proxy
            # This is where 'getaddrinfo failed' was happening. 
            # Ensure p_host is a valid, reachable DNS name.
            upstream = socket.create_connection((p_host, p_port))
            
            auth_header = f"Proxy-Authorization: {get_kerberos_header(p_host)}\r\n"

            if self.command == 'CONNECT':
                # HTTPS Tunneling (AWS CLI / Terraform)
                req = f"CONNECT {self.path} HTTP/1.1\r\nHost: {self.path}\r\n{auth_header}\r\n"
                upstream.sendall(req.encode())
                
                # Wait for '200 Connection Established'
                res = upstream.recv(4096)
                if b"200" in res:
                    self.send_response(200)
                    self.end_headers()
                    self._relay(self.connection, upstream)
            else:
                # Standard HTTP (curl)
                path = self.path
                if not path.startswith('http'):
                    path = f"http://{self.headers['Host']}{path}"
                
                req = f"{self.command} {path} HTTP/1.1\r\n"
                for k, v in self.headers.items():
                    if k.lower() not in ['proxy-authorization', 'proxy-connection']:
                        req += f"{k}: {v}\r\n"
                req += auth_header + "\r\n"
                
                upstream.sendall(req.encode())
                self._relay(self.connection, upstream)
                
        except socket.gaierror:
            self.send_error(502, f"DNS Error: Could not resolve proxy host '{p_host}'")
        except Exception as e:
            self.send_error(502, f"Bridge Error: {str(e)}")

    def _relay(self, client, upstream):
        sockets = [client, upstream]
        while True:
            r, _, _ = select.select(sockets, [], [], 10)
            if not r: break
            for s in r:
                data = s.recv(16384)
                if not data: return
                (upstream if s is client else client).sendall(data)

    do_GET = do_POST = do_PUT = do_DELETE = do_CONNECT = handle_request

if __name__ == "__main__":
    print("Local Windows Bridge listening on http://127.0.0.1:3128")
    HTTPServer(('127.0.0.1', 3128), KerberosBridge).serve_forever()
