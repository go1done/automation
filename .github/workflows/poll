name: Poll AWS CodePipelines from Matrix

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  trigger-pipelines:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        pipeline-name: ["my-pipeline-A", "my-pipeline-B", "my-pipeline-C"]
    
    # Define outputs to be collected by a subsequent job
    outputs:
      execution-id: ${{ steps.trigger.outputs.execution-id }}
      pipeline-name: ${{ matrix.pipeline-name }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Trigger AWS CodePipeline Execution
        id: trigger
        run: |
          # The aws codepipeline start-pipeline-execution command triggers a pipeline.
          # We use jq to parse the ExecutionId from the JSON output.
          # The output is then set as a step output.
          EXECUTION_ID=$(aws codepipeline start-pipeline-execution --name ${{ matrix.pipeline-name }} | jq -r '.pipelineExecutionId')
          echo "Triggered pipeline '${{ matrix.pipeline-name }}' with execution ID: $EXECUTION_ID"
          echo "execution-id=$EXECUTION_ID" >> $GITHUB_OUTPUT

poll_and_summarize:
    runs-on: ubuntu-latest
    needs: [trigger_deploy] # Wait for all matrix jobs to complete
    env:
      AWS_REGION: us-east-1
      # Create a consolidated list of the job outputs from the matrix job
      # This is the key to gathering all parallel results
      ALL_EXECUTIONS: ${{ needs.trigger_deploy.outputs.trigger_pipeline }}
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Poll Pipelines and Generate Summary
        id: poll
        run: |
          MAX_POLLS=60      # Maximum number of checks (e.g., 60 * 10s = 10 minutes max wait)
          POLL_INTERVAL=10  # Wait time between polls in seconds
          
          # Initialize the summary table
          SUMMARY_TABLE="| Pipeline | Status | Link |\n| :--- | :--- | :--- |\n"
          
          # 1. Loop through all pipelines started in the matrix job
          for item in $(echo "$ALL_EXECUTIONS" | jq -r 'to_entries[] | .key'); do
              PIPELINE_NAME=$(jq -r '.[env].PIPELINE_NAME' --arg env "$item" <<< "$ALL_EXECUTIONS")
              EXECUTION_ID=$(jq -r '.[env].EXECUTION_ID' --arg env "$item" <<< "$ALL_EXECUTIONS")
              
              STATUS="IN PROGRESS"
              POLL_COUNT=0
              
              # 2. Polling Loop
              echo "::group::Polling CodePipeline: $PIPELINE_NAME (ID: $EXECUTION_ID)"
              while [ "$STATUS" == "InProgress" ] && [ $POLL_COUNT -lt $MAX_POLLS ]; do
                  sleep $POLL_INTERVAL
                  POLL_COUNT=$((POLL_COUNT + 1))
                  
                  # Query CodePipeline for the status of the specific execution ID
                  RESULT=$(aws codepipeline get-pipeline-execution \
                    --pipeline-name $PIPELINE_NAME \
                    --pipeline-execution-id $EXECUTION_ID \
                    --query 'pipelineExecution.status' --output text)
                  
                  STATUS=$RESULT
                  echo "  Poll $POLL_COUNT: Status is $STATUS"
              done
              echo "::endgroup::"
              
              # 3. Final Status and Summary Generation
              PIPELINE_URL="https://${AWS_REGION}.console.aws.amazon.com/codesuite/codepipeline/pipelines/$PIPELINE_NAME/view?region=${AWS_REGION}"
              
              if [ "$STATUS" == "Succeeded" ]; then
                  STATUS_ICON="✅ Succeeded"
                  SUMMARY_TABLE+="| **$PIPELINE_NAME** | **$STATUS_ICON** | [View]($PIPELINE_URL) |\n"
              elif [ "$STATUS" == "Failed" ]; then
                  STATUS_ICON="❌ Failed"
                  SUMMARY_TABLE+="| **$PIPELINE_NAME** | **$STATUS_ICON** | [View]($PIPELINE_URL) |\n"
                  # Set a failure flag for the entire workflow if any pipeline failed
                  echo "::error::Pipeline $PIPELINE_NAME failed."
                  FAIL_FLAG=true
              else
                  STATUS_ICON="🟡 Timed Out"
                  SUMMARY_TABLE+="| **$PIPELINE_NAME** | **$STATUS_ICON** | [View]($PIPELINE_URL) |\n"
                  echo "::error::Pipeline $PIPELINE_NAME timed out after $MAX_POLLS polls."
                  FAIL_FLAG=true
              fi
          done

          # 4. Output the Final Summary
          echo "$SUMMARY_TABLE" >> $GITHUB_STEP_SUMMARY

          # 5. Fail the job if any pipeline failed or timed out
          if [ "$FAIL_FLAG" = true ]; then
              exit 1
          fi
